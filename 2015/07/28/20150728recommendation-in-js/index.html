<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  
  <title>基于图论的简单推荐引擎(译) - QI</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="alternative" href="/atom.xml" title="QI" type="application/atom+xml">
  
  <!--[if lt IE 9]>
    <script type="text/javascript" src="/js/html5.js"></script>
    <script type="text/javascript" src="/js/css3-mediaqueries.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">

</head>
<body>
    <header id="header">
    <div class="nav-warp">
      <nav id="nav" class="w">
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/recommend">推荐</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
        <a id="nav-search" class="icon-search fr" onclick="show_search()" title="搜索"></a>
        <div id="nav-search-input" class="hide">
          <form class="search-form" onsubmit="return dispatch()">
            <input type="hidden" id="site" value="site:http://evanzh7.github.com">
            <input type="text" id="q" class="input-text" name="q" placeholder="搜索">
            <input type="submit" value="" class="input-submit">
          </form>
        </div>
      </nav>
    </div>
    <div id="logo">
      <div class="hg">
      
        <h2 id="site-title">
          <a href="/">QI</a>
        </h2>
        
          <p id="site-description">Let&#39;s hack</p>
        
      
      </div>
    </div>
  </header>

  <section id="main"><article class="post">
  <header class="post-head">
    
  
    
      <h1 class="post-title">基于图论的简单推荐引擎(译)</h1>
    
  

    
<time datetime="2015-07-28T13:33:00.000Z" class="post-time">2015-07-28</time>

  </header>
  
  <section class="post-content typo">
    <p>Using Graph Theory to Build a Simple Recommendation Engine in JavaScript<br>（JavaScript)基于图论的简单推荐引擎  </p>
<p>Leveraging User Behavior to Drive Recommendations<br>利用用户行为来进行推荐  </p>
<blockquote>
<p>Working at Storefront, we’re always excited about new ways we can keep our users engaged. Recommendations or suggestions are a fantastic way for a platform to encourage users to stick around and keep browsing. The problem is, recommendations can be tricky.  </p>
</blockquote>
<p>在Storefront工作，我们总是对我们能够一直使用户忙碌而感到兴奋。推荐或者建议对于一个鼓励用户逗留和持续不停的浏览的平台是一个很神奇的方式。问题在于，推荐是有技巧的。</p>
<a id="more"></a>
<blockquote>
<p>How do we know what to recommend to our customers? Is it similar item descriptions? Colors? Locations? It could be anything, and a linear combination of parameters grows significantly in complexity with every additional variable. If we use SQL queries, they can quickly become unmanageable tangled messes of JOINs. These can that take minutes to hours to generate unique recommendations for each and every user across your entire user base.    </p>
</blockquote>
<p>我们如何知道推荐什么给客户。是简单的物品描述？颜色？还是地理位置？推荐可以时任何东西，参数的线性组合在附带每个附加变量的复杂情况下增长显著。如果我们使用sql查询，推荐将很快变成不可控的样子，sql语句会变成有一大推join存在的混乱样子。对于整个用户群中每个用户推荐将会花费几分钟到几小时不等的时间去产生一个个性化的推荐。  </p>
<blockquote>
<p>With a very small team and limited resources we wanted a robust recommendation engine that A) wouldn’t lead users astray (random recommendations were out of the question), B) was extremely performant and C) worked with our current stack (node.js). What was our best option to accomplish this?</p>
</blockquote>
<p>仅拥有很小的团队和有限的资源，但是我们想要一个健壮的推荐系统引擎：  </p>
<ol>
<li>不会误导用户，用户不会迷路（随机推荐不在讨论中）  </li>
<li>非常高效</li>
<li>能够兼容现在的工作环境（node.js）</li>
</ol>
<p>能够满足这些要求的最好的选择是什么？  </p>
<p>##1. Introducing the Graph<br>介绍</p>
<blockquote>
<p>If you have a background in computer science or mathematics, you’re probably familiar with graph theory. If not, you stumbled upon the right article to acquaint yourself with it! Many big companies are using graph-theoretic data structures to keep you hooked. LinkedIn’s “how you’re connected.” Facebook’s “people you may know.” You don’t need a lot of resources to begin working with graphs and they can be tremendously useful.  </p>
</blockquote>
<p>如果你的知识背景是计算机科学或者数学，你可能对图论这个概念很熟悉。如果不是的话，你需要找些文章来熟悉图论。许多大公司正在使用图论的数据结构来使用户留下来。LinkedIn的“你是怎样被连结的“，Facebook的”你也许认识的人“。使用图不需要很多资源，而且使用图也很有用。  </p>
<blockquote>
<p>Graphs, quite simply, are a way to model complex relationships between many objects. A graph exists as a collection of nodes (also known as vertices) and edges. A node is merely an abstract data point — it could represent anything. A person, a computer, a building, an intersection… or whatever you’d like. An edge connects two nodes and can optionally be directional (information only flows one way).  </p>
</blockquote>
<p>图，很简单，是一种模拟物体之间复杂关系的方式。一个图以点和边的集合的方式存在。点是一种抽象的数据形式，可以代表一切事物，例如一个人、一个计算机、一栋建筑物、一个十字路口或者你喜欢的任何东西。一条边连结两个点，边可以是有方向的（信息的流动是单向的），也可以是无方向的。  </p>
<p>举个栗子：<br>Node[张大可]:Edge[喜欢]–&gt;Node[酸奶]  </p>
<blockquote>
<p>In this case, we have two nodes (Joe and Minecraft) and one directional edge (likes) connecting the two. What does this look like in code?    </p>
</blockquote>
<p>在这个例子中，存在两个点（张大可 和 酸奶）和一条有向边连结两个顶点。如何用代码来表示以上关系？  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> joe = &#123;<span class="attr">type</span>: <span class="string">'node'</span>, <span class="attr">properties</span>: &#123;<span class="attr">name</span>: <span class="string">'joe'</span>&#125;, <span class="attr">input</span>: [], <span class="attr">output</span>: []&#125;;</span><br><span class="line"><span class="keyword">let</span> likes = &#123;<span class="attr">type</span>: <span class="string">'edge'</span>, <span class="attr">properties</span>: &#123;<span class="attr">name</span>: <span class="string">'likes'</span>&#125;, <span class="attr">input</span>: <span class="literal">null</span>, <span class="attr">output</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> minecraft = &#123;<span class="attr">type</span>: <span class="string">'node'</span>, <span class="attr">properties</span>: &#123;<span class="attr">name</span>: <span class="string">'minecraft'</span>&#125;, <span class="attr">input</span>: [], <span class="attr">output</span>: []&#125;;</span><br><span class="line"></span><br><span class="line">joe.output.push(likes);</span><br><span class="line">likes.input = joe;</span><br><span class="line">likes.output = minecraft;</span><br><span class="line">minecraft.input.push(likes);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we can see that joe.output[0] references likes, likes.input and likes.output reference joe and minecraft respectively (directionally), and minecraft.input[0] references likes.  </p>
</blockquote>
<p>现在我们了解到joe.output[0]代表likes，likes.input和output分别代表joe和minecraft，minicraft.input[0]代表likes。</p>
<p>##2. Creating Our Data Structures<br>创建我们的数据结构  </p>
<blockquote>
<p>There’s a problem here, though, and it’s glaringly obvious: if we want our graph to be assembled effectively, we have to write at least four separate instructions to connect two nodes via an edge. Not only that, but our node and edge constructors (via object literals) are pretty heavy. We can simplify this with object orientation. Let’s introduce some <a href="https://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/" target="_blank" rel="noopener">prototypes</a> via the <a href="http://www.2ality.com/2015/02/es6-classes-final.html" target="_blank" rel="noopener">ES6 Class semantics</a>.  </p>
</blockquote>
<p>存在一个问题，很明显：如果想要将图有效的集合起来，我们不得不引入四个独立的部分，以便连结两个顶点和一条边。不仅如此，点和边的构造函数过于复杂，我们可以使用面向对象的思想简化它。让我们来看一看ES6语义的原型。</p>
<blockquote>
<p>First, we’ll define a base prototype for shared behavior between Nodes and Edges. Let’s call it a Unit, because that’s easy. We want our Unit to be able to specify an entity (what classification of object is it?) and have properties and methods related to setting and retrieving these properties.  </p>
</blockquote>
<p>首先，我们定义一个基本点原型，方便共享节点和边的共享。我们叫它Unit。Unit可以详细说明一个实体，它有属性，和用于设置属性之和获取属性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Entity is used as node or edge type, for different classifications</span></span><br><span class="line">  <span class="comment">//    i.e. 'person', 'game', 'road', etc.</span></span><br><span class="line">  <span class="keyword">constructor</span>(entity, properties) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.entity = entity + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.load(properties || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// load properties (id, name, age, etc.) from an object</span></span><br><span class="line">  load(properties) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(properties).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      p[v] = properties[v];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.properties = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  set(property, value) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.properties[property] = value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unset(property) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span> <span class="keyword">this</span>.properties[property];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(property) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="keyword">this</span>.properties, property);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(property) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.properties[property];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>.constructor.name, <span class="string">' ('</span>, <span class="keyword">this</span>.entity, <span class="string">' '</span>, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.properties) ,<span class="string">')'</span>].join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Great! That’s a good start. Now we need to define our Node where we keep track of all edges, input edges, and output edges (for directionality). We also specify an unlink method to remove all connected edges.</p>
</blockquote>
<p>现在我们需要定义节点，以便使节点能够连接到所有的边，包括输入边和输出边。我们也要指定一个unlink方法用于移除连接关系的边。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">extends</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(entity, properties) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(entity, properties);</span><br><span class="line">    <span class="keyword">this</span>.edges = [];</span><br><span class="line">    <span class="keyword">this</span>.inputEdges = [];</span><br><span class="line">    <span class="keyword">this</span>.outputEdges = [];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  unlink() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> edges = <span class="keyword">this</span>.edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = edges.length; i &lt; len; i++) &#123;</span><br><span class="line">      edges[i].unlink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pretty lightweight, but there’s a bunch of functionality we’ll need to include in our Edge that takes care of connecting nodes to one another. In our edge we hold an inputNode, an outputNode and whether or not the edge is a duplex link (bi-directional).</p>
</blockquote>
<p>轻量级的代码。有一些功能我们需要定义在Edge的定义中，以便能够连结一个点到另一个点。在Edge中我们要定义inputNdoe, outputNode, 一条边是否是双向边。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">extends</span> <span class="title">Unit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(entity, properties) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(entity, properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.inputNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.outputNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.duplex = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.distance = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// link a specific node in a certain direction</span></span><br><span class="line">  _linkTo(node, direction) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      node.inputEdges.push(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      node.outputEdges.push(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.edges.push(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// link two nodes, optionally make edge bidirectional (duplex)</span></span><br><span class="line">  link(inputNode, outputNode, duplex) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.unlink();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.inputNode = inputNode;</span><br><span class="line">    <span class="keyword">this</span>.outputNode = outputNode;</span><br><span class="line">    <span class="keyword">this</span>.duplex = !!duplex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duplex) &#123;</span><br><span class="line">      <span class="keyword">this</span>._linkTo(inputNode, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">this</span>._linkTo(outputNode, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._linkTo(inputNode, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>._linkTo(outputNode, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// distance for traversal</span></span><br><span class="line">  setDistance(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.distance = <span class="built_in">Math</span>.abs(<span class="built_in">parseFloat</span>(v) || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// weight is 1 / distance</span></span><br><span class="line">  setWeight(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.distance = <span class="number">1</span> / <span class="built_in">Math</span>.abs(<span class="built_in">parseFloat</span>(v) || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the opposite node given a starting node</span></span><br><span class="line">  oppositeNode(node) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inputNode === node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.outputNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.outputNode === node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.inputNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// unlink edge, remove connections from nodes</span></span><br><span class="line">  unlink() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pos;</span><br><span class="line">    <span class="keyword">let</span> inode = <span class="keyword">this</span>.inputNode;</span><br><span class="line">    <span class="keyword">let</span> onode = <span class="keyword">this</span>.outputNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(inode &amp;&amp; onode)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (pos = inode.edges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; inode.edges.splice(pos, <span class="number">1</span>);</span><br><span class="line">    (pos = onode.edges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; onode.edges.splice(pos, <span class="number">1</span>);</span><br><span class="line">    (pos = inode.outputEdges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; inode.outputEdges.splice(pos, <span class="number">1</span>);</span><br><span class="line">    (pos = onode.inputEdges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; onode.inputEdges.splice(pos, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.duplex) &#123;</span><br><span class="line"></span><br><span class="line">      (pos = inode.inputEdges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; inode.inputEdges.splice(pos, <span class="number">1</span>);</span><br><span class="line">      (pos = onode.outputEdges.indexOf(<span class="keyword">this</span>)) &gt; <span class="number">-1</span> &amp;&amp; onode.outputEdges.splice(pos, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.inputNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.outputNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.duplex = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3. Re-implementing our Graph<br>重新实现我们的图  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create nodes...</span></span><br><span class="line"><span class="keyword">let</span> joe = <span class="keyword">new</span> Node(<span class="string">'person'</span>);</span><br><span class="line">joe.set(<span class="string">'name'</span>, <span class="string">'Joe'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minecraft = <span class="keyword">new</span> Node(<span class="string">'game'</span>);</span><br><span class="line">minecraft.set(<span class="string">'name'</span>, <span class="string">'Minecraft'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create edge...</span></span><br><span class="line"><span class="keyword">let</span> likes = <span class="keyword">new</span> Edge(<span class="string">'likes'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// link 'em!</span></span><br><span class="line">likes.link(joe, minecraft);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add more nodes...</span></span><br><span class="line"><span class="keyword">let</span> notch = <span class="keyword">new</span> Node(<span class="string">'person'</span>, &#123;<span class="attr">name</span>: <span class="string">'Notch'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> created = <span class="keyword">new</span> Edge(<span class="string">'created'</span>).link(notch, minecraft);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We added a bit, so the graph now looks something like:</p>
<p>N[Joe] : E[likes] → N[Minecraft] ← E[created] : N[Notch]</p>
<p>We can increase the complexity of our graph (so it isn’t just linear!) as much as we want.</p>
</blockquote>
<p>我们增加了一些东西，所以图现在看起来是这样的。可以随心所欲的增加图的复杂性。<br>N[Joe] : E[likes] → N[Minecraft] ← E[created] : N[Notch]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add even more nodes</span></span><br><span class="line"><span class="keyword">let</span> mojang = <span class="keyword">new</span> Node(<span class="string">'company'</span>, &#123;<span class="attr">name</span>: <span class="string">'Mojang'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> microsoft = <span class="keyword">new</span> Node(<span class="string">'company'</span>, &#123;<span class="attr">name</span>: <span class="string">'Microsoft'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> jennifer = <span class="keyword">new</span> Node(<span class="string">'person'</span>, &#123;<span class="attr">name</span>: <span class="string">'Jennifer'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Edge(<span class="string">'founded'</span>).link(notch, mojang);</span><br><span class="line"><span class="keyword">new</span> Edge(<span class="string">'acquired'</span>).link(microsoft, mojang);</span><br><span class="line"><span class="keyword">new</span> Edge(<span class="string">'purchased'</span>).link(jennifer, minecraft);</span><br><span class="line"><span class="keyword">new</span> Edge(<span class="string">'prints_money_for'</span>).link(minecraft, microsoft);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Our new graph...</span></span><br><span class="line"><span class="comment">                    Jennifer</span></span><br><span class="line"><span class="comment">                       | (purchased)</span></span><br><span class="line"><span class="comment">                       v</span></span><br><span class="line"><span class="comment">  Joe --(likes)--&gt; Minecraft &lt;--(created)-- Notch</span></span><br><span class="line"><span class="comment">    (prints_money_for) |                      | (founded)</span></span><br><span class="line"><span class="comment">                       v                      v</span></span><br><span class="line"><span class="comment">                   Microsoft --(acquired)--&gt; Mojang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Awesome. But how would we use a structure like this to drive recommendations for our users? Let’s switch gears to apply this to our business and our product.</p>
</blockquote>
<p>很好，但是我们如何使用这样一个数据结构来为用户进行推荐呢？让我们转向应用这个数据结构到业务和产品中。</p>
<p>##4. Mapping User Behavior<br>映射用户行为  </p>
<blockquote>
<p>Now that we have the basic data structures of our graph set up, let’s map our users’ behavior on to a graph. At Storefront, we have at least three basic ways user can interact with a listing: they can A) view a listing, B) favorite a listing or C) request to book a listing. We’ll use these three actions as our edges, and we’ll define two node types, user and listing.</p>
</blockquote>
<p>现在我们已经拥有了基础的数据结构，让我们映射用户的行为到图上。在Storefront，用户与一个listing交互至少有3种基本的行为:  </p>
<ol>
<li>访问一个列表</li>
<li>将一个列表加入喜爱</li>
<li>订阅一个列表</li>
</ol>
<p>这些动作作为图的边，我们将定义两种节点，用户(user)和列表(listing)。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = getUsers();         <span class="comment">// abstract function to get user data (i.e. SQL)</span></span><br><span class="line"><span class="keyword">let</span> listings = getListings();   <span class="comment">// ... listings</span></span><br><span class="line"><span class="keyword">let</span> views = getViews();         <span class="comment">// ... etc.</span></span><br><span class="line"><span class="keyword">let</span> favorites = getFavorites();</span><br><span class="line"><span class="keyword">let</span> requests = getRequests();</span><br><span class="line"></span><br><span class="line"><span class="comment">// quick and dirty O(n) function to get a node by id</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNodeById</span>(<span class="params">nodes, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nodes.filter(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.get(<span class="string">'id'</span>) === id;</span><br><span class="line">  &#125;)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users = users.map(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'user'</span>, user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">listings = listings.map(<span class="function"><span class="keyword">function</span>(<span class="params">listing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'listing'</span>, listing);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">views = views.map(<span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Edge(<span class="string">'view'</span>)</span><br><span class="line">    .link(getNodeById(users, view.user_id), getNodeById(listings, view.listing_id));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">favorites = favorites.map(<span class="function"><span class="keyword">function</span>(<span class="params">favorite</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Edge(<span class="string">'favorite'</span>)</span><br><span class="line">    .link(getNodeById(users, favorite.user_id), getNodeById(listings, favorite.listing_id));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">requests = requests.map(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Edge(<span class="string">'request'</span>)</span><br><span class="line">    .link(getNodeById(users, request.user_id), getNodeById(listings, request.listing_id));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Voila! Keep in mind, this graph is represented entirely in memory (RAM). For very large user bases (and large numbers of actions) this can be quite a memory hog. You can decrease the memory space by grouping all actions of a certain type between a user and a listing into a single edge, and ignoring users who haven’t performed actions on your website.</p>
</blockquote>
<p>记住，这个图是在内存中表示的。如果大量的用户(大量动作)，将会占用非常多的内存。你可以通过以下方法降低内存，将一个用户和一个列表点所有动作分组到一条边。或者忽略那些没有对你的网站执行操作的用户。</p>
<p>##5. Weighting Interactions<br>为交互添加权重</p>
<blockquote>
<p>Before we’re ready to start giving out recommendations, we need to assign weights (or distances) to each of our user behaviors. We want more important actions to be weighted more favorably. The reason why will become clear when we put everything together. “Weight” and “distance” are inverses of each other, with a higher weight equating to a lower distance.</p>
</blockquote>
<p>在我们给出推荐之前，我们需要为每个用户的行为分配权重。我们希望重要的行为被分配更大的权重。权重和距离是反义词。一条边分配一个大的权重意味着分配小一些的距离。  </p>
<blockquote>
<p>We’ll deal with setting distances because they’re easier to reason about when traversing graphs. Since requests are the most important, we’ll set them to a distance of 1, favorites to 2, and views to 4.</p>
</blockquote>
<p>我们会处理设定距离，访问请求是最重要的，我们将其设定为1，最爱设定为2，查看设定为4。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">views.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">  view.setDistance(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">favorites.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">favorite</span>) </span>&#123;</span><br><span class="line">  favorite.setDistance(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">requests.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  request.setDistance(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终，我们准备开始进行推荐！</p>
<p>##6. Putting it All Together<br>整合</p>
<blockquote>
<p>In order to gain meaningful insights from our graph we’ll need to start exploring it. Why? How does this provide us with recommendations? Well, what we’re going to do is use the emergent behavior of our users to tell us what listings are related to one another. Compared to pulling a bunch of levers and adjusting SQL query parameters, we’re just going to make the assumption that two listings are probably similar to each other if users have interacted with both of them in a meaningful way. The more “meaningful” that interaction, the more likely the listings are similar.</p>
</blockquote>
<p>为了从图中获得有意义的见解，我们需要探索它。为什么呢？图如何为们提供推荐建议？我们要做的就是使用户自发的告诉我们一个列表是如何联系到另一个列表的。相比使用sql，调整sql参数，我们只需要做一个假设，如果两个用户以一种有意义的方式访问了两个列表，我们就认为这两个列表是彼此相似的。越有意义的行为，则列表之间越相似。</p>
<blockquote>
<p>This explains our distances (weights) of user interactions above. If User 1 requests Listing A, User 2 requests Listing A and Listing B, then User 1 is a total distance of 3 away from Listing B on our graph. Let’s visualize.</p>
<p>User 1 : Req (1) → Listing A ← Req (1) : User 2 : Req (1) → Listing B</p>
<p>The distance (3) is calculated as the total length of edges between the two nodes (request + request + request). What we’re going to want to do to generate recommendations is start traversing our graph outwards from our user, and find all of the closest listings in the order that they appear.</p>
</blockquote>
<p>这解释了我们上面定义的距离（权重），如果用户1请求列表A，用户2请求列表A和列表B，然后用户1在图中距离列表B的距离是3。<br>User 1 : Req (1) → Listing A ← Req (1) : User 2 : Req (1) → Listing B<br>距离3是由两个节点的边的总距离得来的。我们产生建议的方法是从用户出发遍历图，找出所有临近的列表。  </p>
<blockquote>
<p>Lucky for us, graph traversal is a very well-studied and documented area of mathematics and computer science. We’re going to be traversing our graph outwards from the user we wish to generate recommendations for, breadth-first. Because our edges have weights and we don’t know enough about our data set to apply heuristics effectively, we’ll use a JavaScript implementation of a modified Dijkstra’s Algorithm that will scan nodes outwards from our target (a specific user).</p>
</blockquote>
<p>所幸的是，图的遍历是一门已经经过充分研究和记录的数学和计算机科学领域。我们将要从用户开始向外遍历，使用深度遍历来产生推荐建议。因为边是有权重多，对于数据集我们了解的不够多，所以不能用启发式算法。我们将使用改进的Dijkstra算法的javascript实现来扫描表，从一个特定的用户开始扫描。</p>
<blockquote>
<p>Using this algorithm we can keep track of every node we find along the way, ordered by distance. As we continue, nodes are progressively further away and (hypothetically) less relevant. For example, we’re interested in the listings another user has requested if they’ve requested the same space as you in the past. We’re not nearly as interested in the listings they have viewed (which is why the distance for views is 4). Because the listings they have viewed (as opposed to requested or favorited) are further out, they’ll be traversed far later than the listings they have requested and won’t have as high of a precedence in our list of recommended spaces.</p>
</blockquote>
<p>使用这种算法我们能够跟踪访问路径上的每一个节点，并且按照距离排序。当我们继续访问时，节点之间距离逐渐变远，相关性也逐渐降低。例如，我们对一个其他用户已经request过的列表感兴趣，我们基本不会对他们view过的列表感兴趣（这就是为什么view的距离是4的原因）。因为他们view（同request, favorite相反）过的列表距离更远。这些列表将会比他们request过的列表距离更远的地方才能被访问到，这些节点也不会比在推荐区域中的清单有更高的优先级。</p>
<blockquote>
<p>I’ll save you the hassle of mastering Dijkstra’s Algorithm in this article, but I encourage you to investigate more on your own if you’re not familiar with graph traversal or need a refresher.</p>
</blockquote>
<p>在这篇文章中我会免去掌握Dijkstra算法的难处，如果你对图遍历不熟悉的话，我鼓励你更多的自己去研究。</p>
<p>##7. Final Implementation<br>最终实现  </p>
<blockquote>
<p>If you were worried you’ll have to figure this all out on your own, we have you covered. UnitGraph is a lightweight io.js (node.js) graph library that uses the data structures outlined here, so you don’t have to make it on your own. It provides a Graph wrapper that allows you to find the closest nodes on a graph or trace the shortest route between two nodes and it’s what we’re currently using in production.</p>
</blockquote>
<p>如果你担心所有这一切都必须你自己亲自来实现，你不必担心，我们已经都实现了。Unitgraph是一个轻量级点io.js图库，它使用这里列出的数据结构，所以你不必自己来编写。它提供了一个图包装器，允许你去寻找一个图中最近的节点，或者找到两个节点间最近的路径。这就是我们现在所做的。  </p>
<blockquote>
<p>Generating our graph now looks like the following:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ug = <span class="built_in">require</span>(<span class="string">'ug'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> ug.Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = getUsers();         <span class="comment">// abstract function to get user data (i.e. SQL)</span></span><br><span class="line"><span class="keyword">let</span> listings = getListings();   <span class="comment">// ... listings</span></span><br><span class="line"><span class="keyword">let</span> views = getViews();         <span class="comment">// ... etc.</span></span><br><span class="line"><span class="keyword">let</span> favorites = getFavorites();</span><br><span class="line"><span class="keyword">let</span> requests = getRequests();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add to graph</span></span><br><span class="line"></span><br><span class="line">users.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  graph.createNode(<span class="string">'user'</span>, user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">listings.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">listing</span>) </span>&#123;</span><br><span class="line">  graph.createNode(<span class="string">'listing'</span>, listing);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">views.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">  graph.createEdge(<span class="string">'view'</span>).link(</span><br><span class="line">    graph.nodes(<span class="string">'user'</span>).find(view.user_id),</span><br><span class="line">    graph.nodes(<span class="string">'listing'</span>).find(view.listing_id)</span><br><span class="line">  ).setDistance(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">favorites.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">favorite</span>) </span>&#123;</span><br><span class="line">  graph.createEdge(<span class="string">'favorite'</span>).link(</span><br><span class="line">    graph.nodes(<span class="string">'user'</span>).find(favorite.user_id),</span><br><span class="line">    graph.nodes(<span class="string">'listing'</span>).find(favorite.listing_id)</span><br><span class="line">  ).setDistance(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">requests.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  graph.createEdge(<span class="string">'request'</span>).link(</span><br><span class="line">    graph.nodes(<span class="string">'user'</span>).find(request.user_id),</span><br><span class="line">    graph.nodes(<span class="string">'listing'</span>).find(request.listing_id)</span><br><span class="line">  ).setDistance(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// save graph</span></span><br><span class="line">graph.save(<span class="string">'/path_to_saved_graph.ugd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  doAfterSave(); <span class="comment">// do whatever you'd like.</span></span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here’s an example of querying for the 100 closest listings to a user on the graph:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ug = <span class="built_in">require</span>(<span class="string">'ug'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> ug.Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">// load graph from flatfile into RAM</span></span><br><span class="line">graph.load(<span class="string">'/path_to_saved_graph.ugd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the closest 100 'listings' nodes, at a minimum depth (distance) of 3</span></span><br><span class="line">  <span class="keyword">let</span> results = graph.closest(node, &#123;</span><br><span class="line">    compare: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123; <span class="keyword">return</span> node.entity === <span class="string">'listing'</span>; &#125;,</span><br><span class="line">    minDepth: <span class="number">3</span>,</span><br><span class="line">    count: <span class="number">100</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// results is now an array of Paths, which are each traces from your starting node to your result node...</span></span><br><span class="line">  <span class="keyword">let</span> resultNodes = result.map(<span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.end();</span><br><span class="line">  &#125;));</span><br><span class="line">  </span><br><span class="line">  doSomething(resultNodes); <span class="comment">// render, whatever you'd like</span></span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You’ll notice minDepth in the graph.closest() call is set to 3. This is to prevent recommending listings to a user that the user has already favorited or requested (distances of 1 and 2, respectively). A distance of at least 3 guarantees we’ll only be recommending listings to users that they’ve at least already viewed.</p>
</blockquote>
<p>你可能注意到了在graph.closest()调用中被设置为了3，这是为了防止向一个用户推荐列表时这个列表是用户曾经favorite过或者request过的(距离分别是1和2)。距离为3保证了我们只会推荐他们仅view过的列表。</p>
<p>后面文章讲述框架的一些优点和不足，可扩展性未来会有带加强的，但是现在还不是很强。</p>
<p><a href="https://github.com/keithwhor/UnitGraph" target="_blank" rel="noopener">additional documentation for UnitGraph here</a><br><a href="https://github.com/keithwhor/nodal" target="_blank" rel="noopener">An ES6 API Server and Framework for iojs</a></p>
<p><a href="http://medium.stfi.re/@keithwhor/using-graph-theory-to-build-a-simple-recommendation-engine-in-javascript-ec43394b35a3?sf=wjpde" target="_blank" rel="noopener">原文地址</a></p>

  </section>
  
  <footer class="post-foot">
    <section class="post-foot-warp clear">
      
  <ul class="post-tag icon-tag fl">
    
      <li><a href="/tags/推荐系统/">#推荐系统</a></li>
    
  </ul>

      
  <ul class="post-category icon-category fr">
    
      <li><a href="/categories/翻译/">翻译</a></li>
    
  </ul>

    </section>
  </footer>
  
</article>

    
<nav id="post-nav" class="clear">
  
    <a href="/2015/07/29/20150729ali-interview/" id="post-nav-newer" class="post-nav-link-wrap fl" title="阿里面试题">
      <div class="post-nav-title">&laquo; 阿里面试题</div>
    </a>
  
  
    <a href="/2015/07/20/20150720spring-autowire/" id="post-nav-older" class="post-nav-link-wrap fr" title="spring自动装配">
      <div class="post-nav-title">spring自动装配 &raquo;</div>
    </a>
  
</nav>



<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-20150728recommendation-in-js" data-title="基于图论的简单推荐引擎(译)" data-url="http://evanzh7.github.com/2015/07/28/20150728recommendation-in-js/"></div>
  <!-- 多说评论框 end -->
</section>
</section>
    <footer id="footer">
    <div class="foot-warp">
      <p>© 2014 QI</p>
    </div>
  </footer>
  <script src="/js/tools.js"></script>
  
  
  <script type="text/javascript">
    var duoshuoQuery = {short_name:'evanzh7'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  
  
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</body>
</html>